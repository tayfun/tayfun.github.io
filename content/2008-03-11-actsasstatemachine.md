name: actsasstatemachine
layout: post
title: acts_as_state_machine
time: 2008-03-11 15:12:00 +02:00

I have recently begun using several Rails plugins after having coded many things by hand. I think its better when you code everything by hand in the beginning but after some time it will be inevitable that you use others' plugins. Anyway, one plugin that I have reasonably struggled to understand is acts_as_state_machine plugin. What it does is, it provides your models with a state. That is, they become stateful. The state itself is of course stored in the database table with column called 'state'. The plugin provides you with simple methods for setting transitions and querying states. Although very useful, it has some quirks of its own.<br /><br />One thing is that when you create a new object with <span style="font-weight: bold;">Class.new</span>, you do not get state property immediately. It's only after you save the object that the state is set. So you can use <span style="font-weight: bold;">'create'</span> method to create and save the object with its state property. Another solution to this problem is setting the default <span style="font-weight: bold;">'state'</span> through migration files. But this has other problems of its own. When you set <span style="font-weight: bold;">state</span> through migrations or simply through <span style="font-weight: bold;">object.state = 'some_state'</span> then you will lose this state data when it is saved to the database. The <span style="font-weight: bold;">'state'</span> property when the object is saved to the database is then set to the initial state defined in the model. Here are some examples for clarity, build on the code from <a href="http://rails.aizatto.com/2007/05/24/ruby-on-rails-finite-state-machine-plugin-acts_as_state_machine/">Aizat's blog (excellent read by the way)</a>:<br /><pre><code><br />class Person < initial =""> :sleeping<br />state :sleeping<br />state :showering<br />state :working<br />state :dating<br /><br />event :shower do<br /> transitions :from => :sleeping, :to => :showering<br /> transitions :from => :working, :to => :showering<br /> transitions :from => :dating, :to => :showering<br />end<br /><br />event :work do<br /> transitions :from => :showering, :to => :working<br /> # Going to work before showering?  Stinky.<br /> transitions :from => :sleeping, :to => :working<br />end<br /><br />event :date do<br /> transitions :from => :showering, :to => :dating<br />end<br /><br />event :sleep do<br /> transitions :from => :showering, :to => :sleeping<br /> transitions :from => :working, :to => :sleeping<br /> transitions :from => :dating, :to => :sleeping<br />end<br />end<br /><br />&gt;&gt; person = Person.new<br />=&gt; #&lt;Person id: nil, state: nil, created_at: nil, updated_at: nil&gt;<br />&gt;&gt; person.shower!<br />NoMethodError: You have a nil object when you didn't expect it!</code></pre><br /><span style="font-weight: bold;">But, here's something interesting:</span><br /><code><br />&gt;&gt; person.state = 'working'<br />=&gt; "working"<br />&gt;&gt; person<br />=&gt; #&lt;Person id: nil, state: "working", created_at: nil, updated_at: nil&gt;<br />&gt;&gt; person.shower!<br />=&gt; true<br />&gt;&gt; person<br />=&gt; #&lt;Person id: 3, state: "sleeping", created_at: "2008-03-11 15:04:41", updated_at: "2008-03-11 15:04:41"&gt;<br /></code><br />It's still sleeping in the end! What I understand is that it doesn't matter what you do until the record is saved. It will still be initialized like it is defined no matter what events you call before.<br />You have to understand how callbacks are called to understand this example.<br /><br />Have a nice day.
