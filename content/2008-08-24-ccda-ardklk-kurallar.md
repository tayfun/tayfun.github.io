name: ccda-ardklk-kurallar
layout: post
title: "C/C++'da Ardışıklık Kuralları"
time: 2008-08-24 12:14:00 +03:00

Herhalde yaklaşık 6 senedir C/C++ kullanıyorum. Çok büyük ve uzun süreli projelere katılmamış olsam da kendimi bir miktar yetkin görürüm. Tez için bir projede çalışırken nedense daha önce pek detaylı araştırmadığım bir konunun farkına vardım: ardışıklık konusu.<br /><br />Aşağıdaki kod parçalarının nasıl çalışacağından emin misiniz?<br /><code>x = x++;<br />(x = 1) * (x = 2);<br />(x = 1) * x;<br />f(), g();<br />f() * g();<br /></code><br />Bir değişkenin ne zaman değerinin alınacağı ("fetch" edileceği) veya değer atanacağı ("set" edileceği) tam olarak bilinmediğinde işlem belirsiz oluyor, etkilerin ne olacağı belirlenemiyor ("race condition" ortaya çıkıyor). Örneğin ilk örnek olan "x = x++"da x daha önce diyelim ki 1 iken, bu işlem sonunda ne olacaktır? Buradaki ++ operatörü sonra geldiği için değer x'in önceki değeri olacak, x artırılacak ve sonra bu değer x'e atanacak. Peki atanma ve artırma olaylarının sırası belirli mi? Cevap belirli olmadığı yönünde. Bu küçük kodu derleyicide derleyip birçok kez çalıştırdığımda cevap her seferinde 2 çıktı. Bu durumda sanki x değerinin arttırılması daha sonra yapılıyormuş gibi görünüyor. Ama bu yanıltıcı bir düşünce, çünkü daha mantıklı gelen (intuitive) başka kod parçalarında diğer düşünce doğru geliyor. Ne olursa olsun bu türden kodlar yazmamak gerekiyor.<br /><br />İkinci ve üçüncü örneklerde çarpım yapılıyor. Sorun burada şu ki C/C++'da çarpım yapılırken değerlerin hangi sırayla belirleneceğı belirli değil. Standart bunu tanımlamıyor, dolayısıyla derleyici üreticileri bu konuda özgürler. Yani demek istediğim şu ki (x = 1)'in mi önce yoksa (x = 2)'nin mi önce çalışacağı belli değil. Kod yazarken bu türden işlemler yazmamak gerekiyor, yani hangisinin önce çalıştırılacağı üzerine varsayım yapmamak, bunun işlemi etkilememesi gerekiyor.<br /><br />Kullandığım dördüncü örnek aslında sorunsuz. C'de virgül operatörü kullandığınızda sıra bellidir. Soldan sağa doğru çalıştırılır ve yalnızca sonuncunun değeri alınır. Dolayısıyla burada ne olacağı belirli.<br /><br />Son örnek ise yine çarpım örneği ve fonksiyonları kullanıyor. Burada da çarpımdaki belirsizlik var. Ancak birşey daha var ki, C'de fonksiyon çağırma iç içe (interleaved) olamıyor. Dolayısıyla biri bittikten sonra diğeri başlayacak. Bir tür atomiklik (atomicity) var. Yine de bu hangisinin önce başlayıp biteceğini bize söylemiyor tabii ki. Dolayısıyla bu türden kod parçalarını da kullanmamalıyız.<br /><br />Bu ardışıklık konusunda daha fazla bilgi için <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n925.htm">birçok</a> <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n926.htm">makale</a> <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n927.htm">var</a>. İlginizi çekiyorsa bir bakın derim. Ama sadece sonuçlarla ilgiliyseniz fazla dalmayın bu konuya, oldukça detaylı çünkü. Bundan başka derleyicinin size bu konuda yardımcı olmasını istiyorsanız <a href="http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#Warning-Options">bu adresteki</a> -Wsequence-point seçeneğine bir bakın derim. GCC'nin size ne kadar yardım edebileceğine şaşırabilirsiniz.<br /><br />Şimdi ben bu konuya nereden dalmıştım... Elimde şöyle bir kod parçası var:<br /><code>map<string, int>::iterator it;<br />for(it = myMap.begin(); it != myMap.end(); it++) {<br />if (it->second < threshold)<br />myMap.erase(it);<br />}<br /></code><br />Burada bir map yapısındaki sınır değerinden düşük elemanlar silinmek isteniyor. Ama bu program segmentation fault verecektir. Sorun şu ki iterator'ı önce siliyoruz sonra da artırarak ilerlemeye çalışıyoruz. Bu durumda silinmiş bir objeye ulaşmaya çalıştığımız için de işletim sistemi kafamıza vuracaktır. Doğru kod şöyle olmalıydı:<br /><code>map<string, int>::iterator it;<br />for(it = myMap.begin(); it != myMap.end(); ) {<br />if (it->second < threshold)<br />myMap.erase(it++);<br />else it++;<br />}<br /></code><br />Böylece silmeden önce it objesi artırılıyor, silerken eski değerin gösterdiği yer siliniyor ve biz yolumuza devam ediyoruz. Mantıklı değil mi? :)
