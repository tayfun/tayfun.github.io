<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="content-language" content="tr">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>C/C++'da Ardışıklık Kuralları | Tayfun Sen</title>
<link rel="icon" type="image/png" href="/favicon.png" />
<link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Ubuntu:700&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css" media="screen" />
<link rel="stylesheet" href="/css/main.css?cache=20150102-01" media="screen" />
<link href="http://blog.tayfunsen.com/feeds/posts/default" rel="alternate" title="Atom" type="application/atom+xml" />
</head>
<body class="homepage" >
<script>
  window.fbAsyncInit = function() {
    FB.init({
      appId      : '482957368512369',
      xfbml      : true,
      version    : 'v2.2'
    });
  };

  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "//connect.facebook.net/en_US/sdk.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>
<div class="container">
  <header class="mainheader">
    <a href="/"><img class="logo img-circle" src="/images/initials.png"></a>
  </header>
  <div id="content">
<article>
    <div class="postheader">
        <div class="posttitle">
            C/C++'da Ardışıklık Kuralları
        </div>
        <div class="postmetadata">
            <span>Written <time class="postdate" datetime="2008-08-24 00:00:00+02:00" pubdate title="on Sun 24 August 2008">on Sun 24 August 2008</time></span>
        </div>
    </div>
    <div class="postcontent">
        <p>Herhalde yaklaşık 6 senedir C/C++ kullanıyorum. Çok büyük ve uzun süreli projelere katılmamış olsam da kendimi bir miktar yetkin görürüm. Tez için bir projede çalışırken nedense daha önce pek detaylı araştırmadığım bir konunun farkına vardım: ardışıklık konusu.<br /><br />Aşağıdaki kod parçalarının nasıl çalışacağından emin misiniz?<br /><code>x = x++;<br />(x = 1) * (x = 2);<br />(x = 1) * x;<br />f(), g();<br />f() * g();<br /></code><br />Bir değişkenin ne zaman değerinin alınacağı ("fetch" edileceği) veya değer atanacağı ("set" edileceği) tam olarak bilinmediğinde işlem belirsiz oluyor, etkilerin ne olacağı belirlenemiyor ("race condition" ortaya çıkıyor). Örneğin ilk örnek olan "x = x++"da x daha önce diyelim ki 1 iken, bu işlem sonunda ne olacaktır? Buradaki ++ operatörü sonra geldiği için değer x'in önceki değeri olacak, x artırılacak ve sonra bu değer x'e atanacak. Peki atanma ve artırma olaylarının sırası belirli mi? Cevap belirli olmadığı yönünde. Bu küçük kodu derleyicide derleyip birçok kez çalıştırdığımda cevap her seferinde 2 çıktı. Bu durumda sanki x değerinin arttırılması daha sonra yapılıyormuş gibi görünüyor. Ama bu yanıltıcı bir düşünce, çünkü daha mantıklı gelen (intuitive) başka kod parçalarında diğer düşünce doğru geliyor. Ne olursa olsun bu türden kodlar yazmamak gerekiyor.<br /><br />İkinci ve üçüncü örneklerde çarpım yapılıyor. Sorun burada şu ki C/C++'da çarpım yapılırken değerlerin hangi sırayla belirleneceğı belirli değil. Standart bunu tanımlamıyor, dolayısıyla derleyici üreticileri bu konuda özgürler. Yani demek istediğim şu ki (x = 1)'in mi önce yoksa (x = 2)'nin mi önce çalışacağı belli değil. Kod yazarken bu türden işlemler yazmamak gerekiyor, yani hangisinin önce çalıştırılacağı üzerine varsayım yapmamak, bunun işlemi etkilememesi gerekiyor.<br /><br />Kullandığım dördüncü örnek aslında sorunsuz. C'de virgül operatörü kullandığınızda sıra bellidir. Soldan sağa doğru çalıştırılır ve yalnızca sonuncunun değeri alınır. Dolayısıyla burada ne olacağı belirli.<br /><br />Son örnek ise yine çarpım örneği ve fonksiyonları kullanıyor. Burada da çarpımdaki belirsizlik var. Ancak birşey daha var ki, C'de fonksiyon çağırma iç içe (interleaved) olamıyor. Dolayısıyla biri bittikten sonra diğeri başlayacak. Bir tür atomiklik (atomicity) var. Yine de bu hangisinin önce başlayıp biteceğini bize söylemiyor tabii ki. Dolayısıyla bu türden kod parçalarını da kullanmamalıyız.<br /><br />Bu ardışıklık konusunda daha fazla bilgi için <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n925.htm">birçok</a> <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n926.htm">makale</a> <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n927.htm">var</a>. İlginizi çekiyorsa bir bakın derim. Ama sadece sonuçlarla ilgiliyseniz fazla dalmayın bu konuya, oldukça detaylı çünkü. Bundan başka derleyicinin size bu konuda yardımcı olmasını istiyorsanız <a href="http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#Warning-Options">bu adresteki</a> -Wsequence-point seçeneğine bir bakın derim. GCC'nin size ne kadar yardım edebileceğine şaşırabilirsiniz.<br /><br />Şimdi ben bu konuya nereden dalmıştım... Elimde şöyle bir kod parçası var:<br /><code>map<string, int>::iterator it;<br />for(it = myMap.begin(); it != myMap.end(); it++) {<br />if (it-&gt;second &lt; threshold)<br />myMap.erase(it);<br />}<br /></code><br />Burada bir map yapısındaki sınır değerinden düşük elemanlar silinmek isteniyor. Ama bu program segmentation fault verecektir. Sorun şu ki iterator'ı önce siliyoruz sonra da artırarak ilerlemeye çalışıyoruz. Bu durumda silinmiş bir objeye ulaşmaya çalıştığımız için de işletim sistemi kafamıza vuracaktır. Doğru kod şöyle olmalıydı:<br /><code>map<string, int>::iterator it;<br />for(it = myMap.begin(); it != myMap.end(); ) {<br />if (it-&gt;second &lt; threshold)<br />myMap.erase(it++);<br />else it++;<br />}<br /></code><br />Böylece silmeden önce it objesi artırılıyor, silerken eski değerin gösterdiği yer siliniyor ve biz yolumuza devam ediyoruz. Mantıklı değil mi? :)</p>
    </div>
    <div class="postfooter">
        <div class="fb-like" data-share="false" data-width="450" data-show-faces="false" data-layout="button"></div>
        <a href="https://twitter.com/share" class="twitter-share-button" data-via="tayfunsen" data-related="tayfunsen" data-dnt="true">Tweet</a>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_shortname = 'tayfunsen';
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
</article>
  </div><!-- content -->
  <div class="footer">
    &copy; <span id="footername">Tayfun Şen</span> 2015. No <span style="background-color:#ccc; padding: 0 3px"><span style="color:red">p</span><span style="color:green">i</span><span style="color:rgb(8, 8, 161)">x</span><span style="color:rgb(143, 6, 5)">e</span><span style="color:black">l</span><span style="color:#2FA5A7">s</span></span> were harmed in during the making of this website. Powered by <a href="https://github.com/getpelican/pelican">Pelican</a>.
  </div><!-- footer -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="/js/main.js"></script>
<script>
var sc_project=2353622;
var sc_invisible=1;
var sc_security="6d6208aa";
</script>
<script src="http://www.statcounter.com/counter/counter.js"></script>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</div><!-- wrapper -->
</body>
</html>